---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# bbx <img src="man/figures/logo.png" align="right" />

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

The goal of `bbx` is to provide convenience functions for working with bounding boxes and geometries for raster images.

## Installation

You can install the development version of bbox from [Github](https://www.github.com) with:

``` r
remotes::install_github("dmi3kno/bbx")
```

## Example

Bounding boxes are common objects in workflows related to processing images. You might have seen them when you worked with `hocr` package or in relation to `hough`-transform functions in `magick`.

This is a basic example which shows you how to solve a common problem:

```{r example}
library(bbx)
## basic example code
library(magrittr)
```


### Validation and area

Bounding box is a character vector (of length 1 or more), where each element contains 4 numbers separated by comma and/or space. These objects are to be interpreted as "x1, y1, x2, y2" coordinates in a raster image (top-left coordinates).

Valid `bbx` is where `x1<x2` and `y1<y2`.

```{r validate}
bbx_is_valid("0 0 100 200")
bbx_validate(c("5,4,6,3", "1,1,5,6"))
```

Sometimes it is useful to know the area of a bounding box

```{r area}
bbx_area("100 100 200 200")
```

### Composing `bbx`

You can create `bbx` objects from four vectors for x1, y1, x2 and y2, respectively (together called coordinates). 

```{r}
coords_to_bbx(c(0,5,0,5), c(0,0,5,5),
              c(5,10,5,10), c(5,5,10,10))
```

The reverse operation is also possible, converting `bbx` to list of coordinates or a list of bounding box vectors.

```{r}
l <- c("0 0 5 5", "5,5,10,10")
bbx_to_rlst(l)
bbx_to_clst(l)
```

These lists have special place in `bbx` package and you can always turn them back into bounding boxes. Think of them as "raw-list" and "coordinate-list". Raw-list is called such, because, even though each element is a numeric vector it is really containing a mix of entities in every element (mixing `x` and `y` coordinates) and therefore requires further processing before it can be used. There's no class assigned to these objects so you need to rememeber which is which.

```{r}
l <- list(c(0,0,5,5), c(5,0,10,5), c(0,5,5,10), c(5,5,10,10))
rlst_to_bbx(l)

l <- list(c(0,5,0,5,0),
          c(0,0,5,5,0),
          c(5,10,5,10,10),
          c(5,5,10,10,10))
clst_to_bbx(l)
```

### Converting to matrix (and back)

Most of calculations performed by `bbx` is done using numeric matrix, so these functions are also exposed to user.

```{r}
bbx_to_bbm(c("0 0 5 5", "5 5 10 10"))
bbm_to_bbx(matrix(c(0,0,5,5,5,5,10,10), nrow=2, byrow=TRUE))
```

You can also extract slope/intersept and angle of bbox diagonals. Note that the function expects a bounding box matrix.

```{r}
m <-bbx_to_bbm(c("0 0 5 5", "5 5 10 10"))
bbm_to_abm(m)
bbm_to_angle(m)
```



### Editing `bbx` objects

In certain instances it might be necessary to update one coordinate of a bounding box in a pipe. The following example with change `x2` coordinate for every incoming `bbx` to a value of 800. 

```{r reset}
c("100 100 200 200", "300 400 500 600") %>% 
 bbx_reset(x2=800)
```

In certain circumstances (especially when performing OCR) it is important to "pad" the word with some empty space. You can do it either by specifying number of pixels directly or by providing a `word`, in which case the number will be interpreted as number of characters to pad (using average character width/height).

```{r}
bbx_pad_width("10 10 40 40", 1)
bbx_pad_width("10 10 40 40", word="There")
bbx_pad_height("10 10 40 40", 1)
bbx_pad_height("10 10 40 40", word="There\nbe\ndragons")
```

### Intersection and aggregation

There are many circumstances where it is important to know whether one `bbx` is intersecting with another `bbx` (or to find a new `bbx` which is the intersection of the two above). Note that it is possible to supply either a single vector or a pair of vectors to this predicate function.

```{r}
bbx_intersects(c("5 1 7 3", "2 4 6 8")) # should return FALSE
bbx_intersects("5 1 7 3", "2 2 6 8") # should return TRUE
```

Once the intersection is assured, area of intesection can be calculated and returned as a new `bbx` object. If the bounding boxes are not overlappling `bbx_intersect` will return `NA`. Intersect is nothing other than `max/pmax()` applied to `x1` and `y1` and `min/pmin()` applied to `x2` and `y2`. 

```{r}
bbx_intersect(c("5 1 7 3", "2 4 6 8")) # should return NA
bbx_intersect("5 1 7 3", "2 2 6 8")
```

In some sense, `union` is opposite of `intersect`. Union is applying `min/pmin()` to `x1`/`y1`, and `max/pmax()` to `x2`/`y2`. 

```{r}
bbx_union(c("5 1 7 3", "2 4 6 8"))
bbx_union2(c("5 1 7 3", "2 4 6 8"), c("1 1 1 1"))
```

However, there is an opportunity to use `bbx_union` (not `bbx_union2`) as aggregation function. You can pass your own aggregating function(s) into optional arguments of `bbx_union` to perform other types of aggregation. This example is aggregating height, but taking median of width.

```{r}
bbx_union(c("5 1 7 3", "2 4 6 8", "10 10 20 20"), fx1=median, fx2=median)
```

### Slicing `bbx`

Sometimes it is necessary to partition existing `bbx` into pieces by "cutting" it horizontally or vertically (or both). It is possible to do it with `bbx_slice_*` functions.

```{r}
bbx_slice_x("0 0 100 200", 80)
bbx_slice_x(c("0 0 100 200", "100 100 200 200"), c(80, 150))
bbx_slice_y("0 0 100 200", 120)
bbx_slice_y(c("0 0 100 200", "100 100 200 200"), c(120,150))
bbx_slice_xy("0 0 100 200", 50, 100)
bbx_slice_xy(c("0 0 100 200", "100,100, 200, 200"), c(50, 150), c(100, 150))
```

### Convert to `magick` geometry

Ultimately `bbx` is intended as input to `image_crop()` (or other "area geometry"-requiring) function in `magick`. The following function will translate `bbx` to geometry and back.

```{r}
bbx_to_geometry("0 0 100 200")
bbx_to_geometry(c("0 0 100 200", "100,100,200, 200"))
geometry_to_bbx(c("100x200+12+14", "100x200", "+12+14", "x200+12+14"))
```



[1] Finger Frame by Magdalene Kan from the Noun Project
